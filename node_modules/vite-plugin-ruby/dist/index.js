var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// node_modules/.pnpm/tsup@5.11.13_typescript@4.5.5/node_modules/tsup/assets/esm_shims.js
import { fileURLToPath } from "url";
import path from "path";
var getFilename = () => fileURLToPath(import.meta.url);
var getDirname = () => path.dirname(getFilename());
var __dirname = /* @__PURE__ */ getDirname();

// src/index.ts
import { basename, posix } from "path";
import createDebugger2 from "debug";

// src/utils.ts
import { readFileSync } from "fs";

// src/constants.ts
var APP_ENV = process.env.RAILS_ENV || process.env.RACK_ENV || process.env.APP_ENV;
var ENV_PREFIX = "VITE_RUBY";
var ALL_ENVS_KEY = "all";
var KNOWN_CSS_EXTENSIONS = [
  "css",
  "less",
  "sass",
  "scss",
  "styl",
  "stylus",
  "pcss",
  "postcss"
];
var KNOWN_ENTRYPOINT_TYPES = [
  "html",
  "jsx?",
  "tsx?",
  ...KNOWN_CSS_EXTENSIONS
];
var CSS_EXTENSIONS_REGEX = new RegExp(`\\.(${KNOWN_CSS_EXTENSIONS.join("|")})$`);
var ENTRYPOINT_TYPES_REGEX = new RegExp(`\\.(${KNOWN_ENTRYPOINT_TYPES.join("|")})(\\?.*)?$`);

// src/utils.ts
function slash(path3) {
  return path3.replace(/\\/g, "/");
}
function isObject(value) {
  return Object.prototype.toString.call(value) === "[object Object]";
}
function screamCase(key) {
  return key.replace(/([a-z])([A-Z])/g, "$1_$2").toUpperCase();
}
function configOptionFromEnv(optionName) {
  return process.env[`${ENV_PREFIX}_${screamCase(optionName)}`];
}
function booleanOption(value) {
  if (value === "true")
    return true;
  if (value === "false")
    return false;
  return value;
}
function withoutExtension(filename) {
  const lastIndex = filename.lastIndexOf(".");
  return lastIndex > -1 ? filename.substr(0, lastIndex) : filename;
}
function loadJsonConfig(filepath) {
  return JSON.parse(readFileSync(filepath, { encoding: "utf8", flag: "r" }));
}
function cleanConfig(object) {
  Object.keys(object).forEach((key) => {
    const value = object[key];
    if (value === void 0 || value === null)
      delete object[key];
    else if (isObject(value))
      cleanConfig(value);
  });
  return object;
}

// src/config.ts
import { join, relative, resolve, isAbsolute } from "path";
import glob from "fast-glob";
var defaultConfig = loadJsonConfig(resolve(__dirname, "../default.vite.json"));
function filterEntrypointsForRollup(entrypoints) {
  return entrypoints.filter(([_name, filename]) => ENTRYPOINT_TYPES_REGEX.test(filename));
}
function filterEntrypointAssets(entrypoints) {
  return entrypoints.filter(([_name, filename]) => !ENTRYPOINT_TYPES_REGEX.test(filename));
}
function filterStylesheetAssets(entrypoints) {
  return entrypoints.filter(([_name, filename]) => CSS_EXTENSIONS_REGEX.test(filename));
}
function isInside(file, dir) {
  const path3 = relative(dir, file);
  return path3 && !path3.startsWith("..") && !isAbsolute(path3);
}
function resolveEntrypointFiles(projectRoot2, sourceCodeDir, config2) {
  const inputGlobs = config2.ssrBuild ? [config2.ssrEntrypoint] : [`~/${config2.entrypointsDir}/**/*`, ...config2.additionalEntrypoints];
  const entrypointFiles = glob.sync(resolveGlobs(projectRoot2, sourceCodeDir, inputGlobs));
  if (config2.ssrBuild) {
    if (entrypointFiles.length === 0)
      throw new Error(`No SSR entrypoint available, please create \`${config2.ssrEntrypoint}\` to do an SSR build.`);
    else if (entrypointFiles.length > 1)
      throw new Error(`Expected a single SSR entrypoint, found: ${entrypointFiles}`);
    return entrypointFiles.map((file) => ["ssr", file]);
  }
  return entrypointFiles.map((filename) => [
    resolveEntryName(projectRoot2, sourceCodeDir, filename),
    filename
  ]);
}
function resolveEntryName(projectRoot2, sourceCodeDir, file) {
  return relative(isInside(file, sourceCodeDir) ? sourceCodeDir : projectRoot2, file);
}
function resolveGlobs(projectRoot2, sourceCodeDir, patterns) {
  return patterns.map((pattern) => slash(resolve(projectRoot2, pattern.replace(/^~\//, `${sourceCodeDir}/`))));
}
function configFromEnv() {
  const envConfig = {};
  Object.keys(defaultConfig).forEach((optionName) => {
    const envValue = configOptionFromEnv(optionName);
    if (envValue !== void 0)
      envConfig[optionName] = envValue;
  });
  return envConfig;
}
function loadConfiguration(viteMode, projectRoot2, userConfig) {
  const envConfig = configFromEnv();
  const mode = envConfig.mode || APP_ENV || viteMode;
  const filePath = join(projectRoot2, envConfig.configPath || defaultConfig.configPath);
  const multiEnvConfig = loadJsonConfig(filePath);
  const fileConfig = __spreadValues(__spreadValues({}, multiEnvConfig[ALL_ENVS_KEY]), multiEnvConfig[mode]);
  return coerceConfigurationValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues({}, defaultConfig), fileConfig), envConfig), { mode }), projectRoot2, userConfig);
}
function coerceConfigurationValues(config2, projectRoot2, userConfig) {
  var _a, _b;
  config2.port = parseInt(config2.port);
  config2.https = ((_a = userConfig.server) == null ? void 0 : _a.https) || booleanOption(config2.https);
  const root = join(projectRoot2, config2.sourceCodeDir);
  const ssrEntrypoint = (_b = userConfig.build) == null ? void 0 : _b.ssr;
  config2.ssrBuild = Boolean(ssrEntrypoint);
  if (typeof ssrEntrypoint === "string")
    config2.ssrEntrypoint = ssrEntrypoint;
  const outDir = relative(root, config2.ssrBuild ? config2.ssrOutputDir : join(config2.publicDir, config2.publicOutputDir));
  const base = resolveViteBase(config2);
  const entrypoints = resolveEntrypointFiles(projectRoot2, root, config2);
  return __spreadProps(__spreadValues({}, config2), { root, outDir, base, entrypoints });
}
function resolveViteBase({ assetHost, base, publicOutputDir }) {
  if (assetHost && !assetHost.startsWith("http"))
    assetHost = `//${assetHost}`;
  return [
    ensureTrailingSlash(assetHost || base || "/"),
    publicOutputDir ? ensureTrailingSlash(slash(publicOutputDir)) : ""
  ].join("");
}
function ensureTrailingSlash(path3) {
  return path3.endsWith("/") ? path3 : `${path3}/`;
}

// src/manifest.ts
import path2 from "path";
import { promises as fsp } from "fs";
import { createHash } from "crypto";
import createDebugger from "debug";
var debug = createDebugger("vite-plugin-ruby:assets-manifest");
function getAssetHash(content) {
  return createHash("sha256").update(content).digest("hex").slice(0, 8);
}
function assetsManifestPlugin() {
  let config2;
  let viteRubyConfig;
  function extractChunkStylesheets(bundle, manifest) {
    const cssFiles = Object.fromEntries(filterStylesheetAssets(viteRubyConfig.entrypoints));
    Object.values(bundle).filter((chunk) => chunk.type === "asset" && chunk.name).forEach((chunk) => {
      if (!config2.build.cssCodeSplit && chunk.name === "style.css")
        return manifest.set(chunk.name, { file: chunk.fileName, src: chunk.name });
      const src = withoutExtension(chunk.name);
      const absoluteFileName = cssFiles[src];
      if (absoluteFileName)
        manifest.set(path2.relative(config2.root, absoluteFileName), { file: chunk.fileName, src });
    });
  }
  async function fingerprintRemainingAssets(ctx, bundle, manifest) {
    const remainingAssets = filterEntrypointAssets(viteRubyConfig.entrypoints);
    for (const [filename, absoluteFilename] of remainingAssets) {
      const content = await fsp.readFile(absoluteFilename);
      const hash = getAssetHash(content);
      const ext = path2.extname(filename);
      const filenameWithoutExt = filename.slice(0, -ext.length);
      const hashedFilename = path2.posix.join(config2.build.assetsDir, `${path2.basename(filenameWithoutExt)}.${hash}${ext}`);
      manifest.set(path2.relative(config2.root, absoluteFilename), { file: hashedFilename, src: filename });
      if (!bundle[hashedFilename])
        ctx.emitFile({ name: filename, fileName: hashedFilename, type: "asset", source: content });
    }
  }
  return {
    name: "vite-plugin-ruby:assets-manifest",
    apply: "build",
    enforce: "post",
    configResolved(resolvedConfig) {
      config2 = resolvedConfig;
      viteRubyConfig = config2.viteRuby;
    },
    async generateBundle(_options, bundle) {
      if (!config2.build.manifest)
        return;
      const manifest = /* @__PURE__ */ new Map();
      extractChunkStylesheets(bundle, manifest);
      await fingerprintRemainingAssets(this, bundle, manifest);
      debug({ manifest });
      this.emitFile({
        fileName: "manifest-assets.json",
        type: "asset",
        source: JSON.stringify(Object.fromEntries(manifest), null, 2)
      });
    }
  };
}

// src/index.ts
var projectRoot = configOptionFromEnv("root") || process.cwd();
var watchAdditionalPaths = [];
function ViteRubyPlugin() {
  return [
    {
      name: "vite-plugin-ruby",
      config,
      configureServer
    },
    assetsManifestPlugin()
  ];
}
var debug2 = createDebugger2("vite-plugin-ruby:config");
function config(userConfig, env) {
  var _a, _b, _c, _d;
  const config2 = loadConfiguration(env.mode, projectRoot, userConfig);
  const { assetsDir, base, outDir, host, https, port, root, entrypoints, ssrBuild } = config2;
  const fs = { allow: [projectRoot], strict: true };
  const server = { host, https, port, strictPort: true, fs };
  const isLocal = config2.mode === "development" || config2.mode === "test";
  const build = __spreadProps(__spreadValues({
    emptyOutDir: (_b = (_a = userConfig.build) == null ? void 0 : _a.emptyOutDir) != null ? _b : ssrBuild || isLocal,
    sourcemap: !isLocal
  }, userConfig.build), {
    assetsDir,
    manifest: !ssrBuild,
    outDir,
    rollupOptions: {
      input: Object.fromEntries(filterEntrypointsForRollup(entrypoints)),
      output: ssrBuild ? {} : __spreadValues(__spreadValues({}, outputOptions(assetsDir)), (_d = (_c = userConfig.build) == null ? void 0 : _c.rollupOptions) == null ? void 0 : _d.output)
    }
  });
  const envDir = userConfig.envDir || projectRoot;
  debug2({ base, build, envDir, root, server, entrypoints: Object.fromEntries(entrypoints) });
  watchAdditionalPaths = resolveGlobs(projectRoot, root, config2.watchAdditionalPaths || []);
  const alias = { "~/": `${root}/`, "@/": `${root}/` };
  return cleanConfig({
    resolve: { alias },
    base,
    envDir,
    root,
    server,
    build,
    viteRuby: config2
  });
}
function configureServer(server) {
  server.watcher.add(watchAdditionalPaths);
}
function outputOptions(assetsDir) {
  const outputFileName = (ext) => ({ name }) => {
    const shortName = basename(name).split(".")[0];
    return posix.join(assetsDir, `${shortName}.[hash].${ext}`);
  };
  return {
    entryFileNames: outputFileName("js"),
    chunkFileNames: outputFileName("js"),
    assetFileNames: outputFileName("[ext]")
  };
}
export {
  ViteRubyPlugin as default,
  projectRoot
};
//# sourceMappingURL=index.js.map