{"version":3,"sources":["../node_modules/.pnpm/tsup@5.11.13_typescript@4.5.5/node_modules/tsup/assets/esm_shims.js","../src/index.ts","../src/utils.ts","../src/constants.ts","../src/config.ts","../src/manifest.ts"],"sourcesContent":["// Shim globals in esm bundle\nimport { fileURLToPath } from 'url'\nimport path from 'path'\n\nconst getFilename = () => fileURLToPath(import.meta.url)\nconst getDirname = () => path.dirname(getFilename())\n\nexport const __dirname = /* @__PURE__ */ getDirname()\nexport const __filename = /* @__PURE__ */ getFilename()\n","import { basename, posix } from 'path'\nimport type { ConfigEnv, PluginOption, UserConfig, ViteDevServer } from 'vite'\nimport createDebugger from 'debug'\n\nimport { cleanConfig, configOptionFromEnv } from './utils'\nimport { filterEntrypointsForRollup, loadConfiguration, resolveGlobs } from './config'\nimport { assetsManifestPlugin } from './manifest'\n\nexport * from './types'\n\n// Public: The resolved project root.\nexport const projectRoot = configOptionFromEnv('root') || process.cwd()\n\n// Internal: Additional paths to watch.\nlet watchAdditionalPaths: string[] = []\n\n// Public: Vite Plugin to detect entrypoints in a Ruby app, and allows to load a shared JSON configuration file that can be read from Ruby.\nexport default function ViteRubyPlugin (): PluginOption[] {\n  return [\n    {\n      name: 'vite-plugin-ruby',\n      config,\n      configureServer,\n    },\n    assetsManifestPlugin(),\n  ]\n}\n\nconst debug = createDebugger('vite-plugin-ruby:config')\n\n// Internal: Resolves the configuration from environment variables and a JSON\n// config file, and configures the entrypoints and manifest generation.\nfunction config (userConfig: UserConfig, env: ConfigEnv): UserConfig {\n  const config = loadConfiguration(env.mode, projectRoot, userConfig)\n  const { assetsDir, base, outDir, host, https, port, root, entrypoints, ssrBuild } = config\n\n  const fs = { allow: [projectRoot], strict: true }\n  const server = { host, https, port, strictPort: true, fs }\n\n  const isLocal = config.mode === 'development' || config.mode === 'test'\n\n  const build = {\n    emptyOutDir: userConfig.build?.emptyOutDir ?? (ssrBuild || isLocal),\n    sourcemap: !isLocal,\n    ...userConfig.build,\n    assetsDir,\n    manifest: !ssrBuild,\n    outDir,\n    rollupOptions: {\n      input: Object.fromEntries(filterEntrypointsForRollup(entrypoints)),\n      output: ssrBuild ? {} : {\n        ...outputOptions(assetsDir),\n        ...userConfig.build?.rollupOptions?.output,\n      },\n    },\n  }\n\n  const envDir = userConfig.envDir || projectRoot\n\n  debug({ base, build, envDir, root, server, entrypoints: Object.fromEntries(entrypoints) })\n\n  watchAdditionalPaths = resolveGlobs(projectRoot, root, config.watchAdditionalPaths || [])\n\n  const alias = { '~/': `${root}/`, '@/': `${root}/` }\n\n  return cleanConfig({\n    resolve: { alias },\n    base,\n    envDir,\n    root,\n    server,\n    build,\n    viteRuby: config,\n  })\n}\n\n// Internal: Allows to watch additional paths outside the source code dir.\nfunction configureServer (server: ViteDevServer) {\n  server.watcher.add(watchAdditionalPaths)\n}\n\nfunction outputOptions (assetsDir: string) {\n  // Internal: Avoid nesting entrypoints unnecessarily.\n  const outputFileName = (ext: string) => ({ name }: { name: string }) => {\n    const shortName = basename(name).split('.')[0]\n    return posix.join(assetsDir, `${shortName}.[hash].${ext}`)\n  }\n\n  return {\n    entryFileNames: outputFileName('js'),\n    chunkFileNames: outputFileName('js'),\n    assetFileNames: outputFileName('[ext]'),\n  }\n}\n","import { readFileSync } from 'fs'\n\nimport { ENV_PREFIX } from './constants'\n\n// Internal: Replace Windows-style separators with POSIX-style separators.\nexport function slash (path: string): string {\n  return path.replace(/\\\\/g, '/')\n}\n\n// Internal: Returns true if the specified value is a plain JS object\nexport function isObject (value: unknown): value is Record<string, any> {\n  return Object.prototype.toString.call(value) === '[object Object]'\n}\n\n// Internal: Simplistic version that gets the job done for this scenario.\n// Example: screamCase('buildOutputDir') === 'BUILD_OUTPUT_DIR'\nexport function screamCase (key: string) {\n  return key.replace(/([a-z])([A-Z])/g, '$1_$2').toUpperCase()\n}\n\n// Internal: Returns a configuration option that was provided using env vars.\nexport function configOptionFromEnv (optionName: string) {\n  return process.env[`${ENV_PREFIX}_${screamCase(optionName)}`]\n}\n\n// Internal: Ensures it's easy to turn off a setting with env vars.\nexport function booleanOption<T> (value: 'true' | 'false' | boolean | T): boolean | T {\n  if (value === 'true') return true\n  if (value === 'false') return false\n  return value\n}\n\n// Internal: Returns the filename without the last extension.\nexport function withoutExtension (filename: string) {\n  const lastIndex = filename.lastIndexOf('.')\n  return lastIndex > -1 ? filename.substr(0, lastIndex) : filename\n}\n\n// Internal: Loads a json configuration file.\nexport function loadJsonConfig<T> (filepath: string): T {\n  return JSON.parse(readFileSync(filepath, { encoding: 'utf8', flag: 'r' })) as T\n}\n\n// Internal: Removes any keys with undefined or null values from the object.\nexport function cleanConfig (object: Record<string, any>) {\n  Object.keys(object).forEach((key) => {\n    const value = object[key]\n    if (value === undefined || value === null) delete object[key]\n    else if (isObject(value)) cleanConfig(value)\n  })\n  return object\n}\n","// Internal: Inferred mode, since Vite doesn't yet expose it to its plugins.\nexport const APP_ENV = process.env.RAILS_ENV || process.env.RACK_ENV || process.env.APP_ENV\n\n// Internal: Prefix used for environment variables that modify the configuration.\nexport const ENV_PREFIX = 'VITE_RUBY'\n\n// Internal: Key of the vite.json file that is applied to all environments.\nexport const ALL_ENVS_KEY = 'all'\n\n// Internal: Extensions of CSS files or known precompilers.\nexport const KNOWN_CSS_EXTENSIONS = [\n  'css',\n  'less',\n  'sass',\n  'scss',\n  'styl',\n  'stylus',\n  'pcss',\n  'postcss',\n]\n\n// Internal: Types of files that Vite should process correctly as entrypoints.\nexport const KNOWN_ENTRYPOINT_TYPES = [\n  'html',\n  'jsx?',\n  'tsx?',\n  ...KNOWN_CSS_EXTENSIONS,\n]\n\nexport const CSS_EXTENSIONS_REGEX = new RegExp(\n  `\\\\.(${KNOWN_CSS_EXTENSIONS.join('|')})$`,\n)\n\nexport const ENTRYPOINT_TYPES_REGEX = new RegExp(\n  `\\\\.(${KNOWN_ENTRYPOINT_TYPES.join('|')})(\\\\?.*)?$`,\n)\n","import { join, relative, resolve, isAbsolute } from 'path'\nimport glob from 'fast-glob'\n\nimport type { UserConfig } from 'vite'\nimport { APP_ENV, ALL_ENVS_KEY, CSS_EXTENSIONS_REGEX, ENTRYPOINT_TYPES_REGEX } from './constants'\nimport { booleanOption, loadJsonConfig, configOptionFromEnv, slash } from './utils'\nimport { Config, ResolvedConfig, UnifiedConfig, MultiEnvConfig, Entrypoints } from './types'\n\n// Internal: Default configuration that is also read from Ruby.\nexport const defaultConfig: ResolvedConfig = loadJsonConfig(resolve(__dirname, '../default.vite.json'))\n\n// Internal: Returns the files defined in the entrypoints directory that should\n// be processed by rollup.\n//\n// NOTE: For stylesheets the original extension is preserved in the name so that\n// the resulting file can be accurately matched later in `extractChunkStylesheets`.\nexport function filterEntrypointsForRollup (entrypoints: Entrypoints): Entrypoints {\n  return entrypoints\n    .filter(([_name, filename]) => ENTRYPOINT_TYPES_REGEX.test(filename))\n}\n\n// Internal: Returns the files defined in the entrypoints directory that are not\n// processed by Rollup and should be manually fingerprinted and copied over.\nexport function filterEntrypointAssets (entrypoints: Entrypoints): Entrypoints {\n  return entrypoints\n    .filter(([_name, filename]) => !ENTRYPOINT_TYPES_REGEX.test(filename))\n}\n\n// Internal: Returns the style files defined in the entrypoints directory that\n// are processed by Rollup but not included in the Vite.js manifest.\nexport function filterStylesheetAssets (entrypoints: Entrypoints): Entrypoints {\n  return entrypoints\n    .filter(([_name, filename]) => CSS_EXTENSIONS_REGEX.test(filename))\n}\n\n// Internal: Checks if the specified path is inside the specified dir.\nfunction isInside (file: string, dir: string) {\n  const path = relative(dir, file)\n  return path && !path.startsWith('..') && !isAbsolute(path)\n}\n\n// Internal: Returns all files defined in the entrypoints directory.\nexport function resolveEntrypointFiles (projectRoot: string, sourceCodeDir: string, config: ResolvedConfig): Entrypoints {\n  const inputGlobs = config.ssrBuild\n    ? [config.ssrEntrypoint]\n    : [`~/${config.entrypointsDir}/**/*`, ...config.additionalEntrypoints]\n\n  const entrypointFiles = glob.sync(resolveGlobs(projectRoot, sourceCodeDir, inputGlobs))\n\n  if (config.ssrBuild) {\n    if (entrypointFiles.length === 0)\n      throw new Error(`No SSR entrypoint available, please create \\`${config.ssrEntrypoint}\\` to do an SSR build.`)\n    else if (entrypointFiles.length > 1)\n      throw new Error(`Expected a single SSR entrypoint, found: ${entrypointFiles}`)\n\n    return entrypointFiles.map(file => ['ssr', file])\n  }\n\n  return entrypointFiles.map(filename => [\n    resolveEntryName(projectRoot, sourceCodeDir, filename),\n    filename,\n  ])\n}\n\n// Internal: All entry names are relative to the sourceCodeDir if inside it, or\n// to the project root if outside.\nexport function resolveEntryName (projectRoot: string, sourceCodeDir: string, file: string) {\n  return relative(isInside(file, sourceCodeDir) ? sourceCodeDir : projectRoot, file)\n}\n\n// Internal: Allows to use the `~` shorthand in the config globs.\nexport function resolveGlobs (projectRoot: string, sourceCodeDir: string, patterns: string[]) {\n  return patterns.map(pattern =>\n    slash(resolve(projectRoot, pattern.replace(/^~\\//, `${sourceCodeDir}/`))),\n  )\n}\n\n// Internal: Loads configuration options provided through env variables.\nfunction configFromEnv (): Config {\n  const envConfig: Record<string, any> = {}\n  Object.keys(defaultConfig).forEach((optionName) => {\n    const envValue = configOptionFromEnv(optionName)\n    if (envValue !== undefined) envConfig[optionName] = envValue\n  })\n  return envConfig\n}\n\n// Internal: Allows to load configuration from a json file, and VITE_RUBY\n// prefixed environment variables.\nexport function loadConfiguration (viteMode: string, projectRoot: string, userConfig: UserConfig): UnifiedConfig {\n  const envConfig = configFromEnv()\n  const mode = envConfig.mode || APP_ENV || viteMode\n  const filePath = join(projectRoot, envConfig.configPath || (defaultConfig.configPath as string))\n  const multiEnvConfig = loadJsonConfig<MultiEnvConfig>(filePath)\n  const fileConfig: Config = { ...multiEnvConfig[ALL_ENVS_KEY], ...multiEnvConfig[mode] }\n\n  // Combine the three possible sources: env > json file > defaults.\n  return coerceConfigurationValues({ ...defaultConfig, ...fileConfig, ...envConfig, mode }, projectRoot, userConfig)\n}\n\n// Internal: Coerces the configuration values and deals with relative paths.\nfunction coerceConfigurationValues (config: ResolvedConfig, projectRoot: string, userConfig: UserConfig): UnifiedConfig {\n  // Coerce the values to the expected types.\n  config.port = parseInt(config.port as unknown as string)\n  config.https = userConfig.server?.https || booleanOption(config.https)\n\n  // Use the sourceCodeDir as the Vite.js root.\n  const root = join(projectRoot, config.sourceCodeDir)\n\n  // Detect SSR builds and entrypoint provided via the --ssr flag.\n  const ssrEntrypoint = userConfig.build?.ssr\n  config.ssrBuild = Boolean(ssrEntrypoint)\n  if (typeof ssrEntrypoint === 'string')\n    config.ssrEntrypoint = ssrEntrypoint\n\n  // Vite expects the outDir to be relative to the root.\n  const outDir = relative(root, config.ssrBuild\n    ? config.ssrOutputDir\n    : join(config.publicDir, config.publicOutputDir))\n\n  const base = resolveViteBase(config)\n  const entrypoints = resolveEntrypointFiles(projectRoot, root, config)\n\n  return { ...config, root, outDir, base, entrypoints }\n}\n\n// Internal: Configures Vite's base according to the asset host and publicOutputDir.\nexport function resolveViteBase ({ assetHost, base, publicOutputDir }: ResolvedConfig) {\n  if (assetHost && !assetHost.startsWith('http')) assetHost = `//${assetHost}`\n\n  return [\n    ensureTrailingSlash(assetHost || base || '/'),\n    publicOutputDir ? ensureTrailingSlash(slash(publicOutputDir)) : '',\n  ].join('')\n}\n\nfunction ensureTrailingSlash (path: string) {\n  return path.endsWith('/') ? path : `${path}/`\n}\n","import path from 'path'\nimport { promises as fsp } from 'fs'\nimport { createHash } from 'crypto'\nimport createDebugger from 'debug'\n\nimport type { Plugin, ResolvedConfig } from 'vite'\n\nimport { OutputBundle, PluginContext } from 'rollup'\nimport { UnifiedConfig } from './types'\nimport { filterEntrypointAssets, filterStylesheetAssets } from './config'\nimport { withoutExtension } from './utils'\n\nconst debug = createDebugger('vite-plugin-ruby:assets-manifest')\n\ninterface AssetsManifestChunk {\n  src?: string\n  file: string\n}\n\ntype AssetsManifest = Map<string, AssetsManifestChunk>\n\nfunction getAssetHash (content: Buffer) {\n  return createHash('sha256').update(content).digest('hex').slice(0, 8)\n}\n\n// Internal: Writes a manifest file that allows to map an entrypoint asset file\n// name to the corresponding output file name.\nexport function assetsManifestPlugin (): Plugin {\n  let config: ResolvedConfig\n  let viteRubyConfig: UnifiedConfig\n\n  // Internal: For stylesheets Vite does not output the result to the manifest,\n  // so we extract the file name of the processed asset from the Rollup bundle.\n  function extractChunkStylesheets (bundle: OutputBundle, manifest: AssetsManifest) {\n    const cssFiles = Object.fromEntries(filterStylesheetAssets(viteRubyConfig.entrypoints))\n\n    Object.values(bundle).filter(chunk => chunk.type === 'asset' && chunk.name)\n      .forEach((chunk) => {\n        // Vite will output a single CSS chunk named style.css\n        if (!config.build.cssCodeSplit && chunk.name === 'style.css')\n          return manifest.set(chunk.name, { file: chunk.fileName, src: chunk.name })\n\n        // NOTE: Rollup appends `.css` to the file so it's removed before matching.\n        // See `filterEntrypointsForRollup`.\n        const src = withoutExtension(chunk.name!)\n        const absoluteFileName = cssFiles[src]\n        if (absoluteFileName)\n          manifest.set(path.relative(config.root, absoluteFileName), { file: chunk.fileName, src })\n      })\n  }\n\n  // Internal: Vite ignores some entrypoint assets, so we need to manually\n  // fingerprint the files and move them to the output directory.\n  async function fingerprintRemainingAssets (ctx: PluginContext, bundle: OutputBundle, manifest: AssetsManifest) {\n    const remainingAssets = filterEntrypointAssets(viteRubyConfig.entrypoints)\n\n    for (const [filename, absoluteFilename] of remainingAssets) {\n      const content = await fsp.readFile(absoluteFilename)\n      const hash = getAssetHash(content)\n\n      const ext = path.extname(filename)\n      const filenameWithoutExt = filename.slice(0, -ext.length)\n      const hashedFilename = path.posix.join(config.build.assetsDir, `${path.basename(filenameWithoutExt)}.${hash}${ext}`)\n\n      manifest.set(path.relative(config.root, absoluteFilename), { file: hashedFilename, src: filename })\n\n      // Avoid duplicates if the file was referenced in a different entrypoint.\n      if (!bundle[hashedFilename])\n        ctx.emitFile({ name: filename, fileName: hashedFilename, type: 'asset', source: content })\n    }\n  }\n\n  return {\n    name: 'vite-plugin-ruby:assets-manifest',\n    apply: 'build',\n    enforce: 'post',\n    configResolved (resolvedConfig: ResolvedConfig) {\n      config = resolvedConfig\n      viteRubyConfig = (config as any).viteRuby\n    },\n    async generateBundle (_options, bundle) {\n      if (!config.build.manifest) return\n\n      const manifest: AssetsManifest = new Map()\n      extractChunkStylesheets(bundle, manifest)\n\n      await fingerprintRemainingAssets(this, bundle, manifest)\n      debug({ manifest })\n\n      this.emitFile({\n        fileName: 'manifest-assets.json',\n        type: 'asset',\n        source: JSON.stringify(Object.fromEntries(manifest), null, 2),\n      })\n    },\n  }\n}\n"],"mappings":"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","names":[]}